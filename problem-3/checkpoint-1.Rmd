---
title: "Analisando a filmografia de Jennifer Lawrence"
author: "Luiz Fonseca"
date: "20 de junho de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r}
# Bibliotecas utilizadas
library(tidyverse, warn.conflicts = F)
library(rvest)
library(plotly)
library(cluster)
library(ggdendro)
theme_set(theme_light())
```

## Objetivo

Nesta análise exploraremos dados sobre a filmografia da atriz americana Jennifer Lawrence. Os dados vêm do site [Rotten Tomatoes](https://www.rottentomatoes.com). O propósito é agrupar os filmes da atriz em categorias plausíveis de acordo com duas variáveis: a avaliaçao do filme no Rotten Tomatoes e a quantidade de dinheiro que o filme arrecadou.

```{r}
# Coletando os filmes pela url do site
from_page <- read_html("https://www.rottentomatoes.com/celebrity/jennifer_lawrence/") %>% 
    html_node("#filmographyTbl") %>% # A sintaxe da expressão é de um seletor à lá JQuery: https://rdrr.io/cran/rvest/man/html_nodes.html 
    html_table(fill=TRUE) %>% # Faz parse
    as.tibble()

# Limpando os dados para que não haja filmes com atributos faltando
filmes = from_page %>% 
    filter(RATING != "No Score Yet", 
           `BOX OFFICE` != "—", 
           CREDIT != "Executive Producer") %>%
    mutate(RATING = as.numeric(gsub("%", "", RATING)), 
           `BOX OFFICE` = as.numeric(gsub("[$|M]", "", `BOX OFFICE`))) %>% 
    filter(`BOX OFFICE` >= 1) # Tem dois filmes que não parecem ter sido lançados no mundo todo

names(filmes) <- c("avaliação", "filme", "papel", "bilheteria", "ano")
```

## Investigando as variáveis
### Avaliação dos usuários
Para cada filme da atriz sabemos o nome do filme, o papel que ela interpretou, o ano de lançamento, a bilheteria e a avaliação do site. Primeiramente, vamos ver se é possível definir grupos de filmes com base na avaliação dos usuários. Os gráficos abaixo podem nos dar alguma noção disso.
```{r}
filmes %>% 
    ggplot(aes(x = "Filmes", y = avaliação)) + 
    geom_jitter(width = .02, height = 0, size = 2, alpha = .6) +
  labs(title = "Avaliação dos filmes de Jennifer Lawrence", x = "")

filmes %>% 
    ggplot(aes(x = avaliação)) + 
    geom_histogram(bins = 16) + 
    geom_rug() +
  labs(title = "Avaliação dos filmes de Jennifer Lawrence (Histograma)", y = "frequência")
```

A avaliação dos usuários do rotten tomatoes vai de 0 a 100. Só de olhar para os gráficos podemos identificar 4 grupos de filmes de acordo com as avaliações que receberam. É claro que esse agrupamento é subjetivo e pode variar de pessoa para pessoa, mais adiante iremos definir os grupos de forma mais objetiva. 

Temos o grupo de filmes bem avaliados com notas maiores que 80, o grupo de filmes não tão bons com notas entre 48 e 75 mais ou menos; um grupo só com um filme de nota 30 (aproximadamente) e outro com um filme de nota 10.

### Ano do filme
Vemos que o agrupamento faz sentido para a variável avaliação. Por outro lado se observamos a variável ano, vemos que um agrupamento não faz muito sentido.
```{r}
filmes %>% 
    ggplot(aes(x = "Filmes", y = ano)) + 
    geom_jitter(width = .02, height = 0, size = 2, alpha = .6) 

filmes %>% 
    ggplot(aes(x = ano)) + 
    geom_histogram(bins = 17) + 
    geom_rug()
```

A não ser que você quisesse que cada grupo fosse um ano. Porém, qual a utilidade desse agrupamento?

### Bilheteria

A variável bilheteria tem uma caraterística interessante: ela pode apresentar valores muito altos, 400 milhões de dólares, por exemplo. Porque isso é importante?

Exemplo I) A diferença de um filme que lucrou 1 milhão de dólares para um filme que lucrou 15 milhões de dólares parece bastante notável. Um lucrou 15 vezes mais do que o outro. 

Exemplo II) Será que a diferença entre um filme que lucrou 450 milhões para um filme que lucrou 465 milhões deve receber a mesma atenção? Afinal, o segundo só lucrou 3% a mais do que o primeiro. 

Isso é importante para a nossa análise, pois apesar de a diferença de lucro dos exemplos serem iguais (15 milhões), essa diferença, para o primeiro caso, parece ser bem mais evidente. Os filmes do segundo exemplo poderiam ser incluídos em um mesmo grupo levando em consideração somente a bilheteria, enquanto que os filmes do primeiro exemplo poderiam estar em categorias separadas: um deles recebeu bem menos do que o outro levando em consideração a soma das duas bilheterias.

Sabendo disso, vamos analisar a variável bilheteria de duas formas: 
I) Utilizando uma escala linear assim como foi feito anteriorente;
II) Utilizando uma escala logarítmica para evidenciar diferenças pequenas apenas para valores pequenos.
```{r}
filmes %>% 
    ggplot(aes(x = "Filmes", y = bilheteria)) + 
    geom_jitter(width = .02, height = 0, size = 2, alpha = .6)  
    
filmes %>% 
    ggplot(aes(x = "Filmes", y = bilheteria)) + 
    geom_jitter(width = .02, height = 0, size = 2, alpha = .6) + 
    scale_y_log10()
```

Os grupos ficam bem mais claros ao utilizar a escala logarítmica. Podemos identificar três grupos: um de grandes sucesssos de bilheteria, com renda em geral acima de 100 milhões de dólares; outro grupo com filmes que não fizeram tanto sucesso; e um terceiro grupo com filmes de renda bem baixa quando comparados com os outros, abaixo de 10 milhões de dólares.

## Agrupamento 
A partir deste ponto iremos utilizar algoritmos para gerar grupos dos filmes. Iremos utilizar várias abordagens e escolhermos a que parecer mais correta.

### Com uma variável
#### Variável: Avaliação
Há duas maneiras principais de agrupar: aglomerativa ou baseada em partição. Vamos explorar primeiro a hierárquica aglomerativa.

Por hora utilizaremos apenas a variável avaliação, para a qual o nosso olhômetro definiu quatro grupos. O algoritmo de agrupamento irá medir as distâncias entre todos os pontos e juntar os dois pontos mais próximos em um grupo. A partir daí esses dois pontos serão tratados como um único e o centro da distância entre esses dois pontos será o ponto levado em consideração para esse grupo formado. A cada iteração (rodada), o algoritmo irá unir os dois pontos mais próximos, formando grupos. No final teremos todos os melhores grupos para cada número de grupos (1, 2, 3, ...) e cabe a nós escolhermos qual o melhor número.

O gráfico abaixo se chama dendrograma e mostra os grupos formados a cada iteração do algoritmo. No eixo y temos os filmes a agrupar e no eixo x temos o tamanho da distância para agrupar dois pontos/grupos, ou seja, quanto maior a linha horizontal que une dois filmes/grupos, maior é a distância ou diferença entre esses filmes/grupos. 

```{r}
row.names(filmes) = NULL
agrupamento_h = filmes %>% 
    column_to_rownames("filme") %>% # hclust precisa dos rótulos em nomes de linha (ruim)
    select(avaliação) %>%
    dist(method = "euclidian") %>% 
    hclust(method = "ward.D2")

ggdendrogram(agrupamento_h, rotate = T, size = 2) + 
    geom_hline(yintercept = 20, colour = "red")
```

Fica a nosso critério escolher qual o número de grupos que melhor define os filmes. Provavelmente a melhor escolha de grupos é a que está cortada pela linha vermelha, pois a distância para unir dois grupos a partir desse ponto é bem maior do que as distâncias anteriores. Entao, para a avaliação teríamos quatro grupos de filmes, assim como háviamos interpretado antes.

O gráfico abaixo nos traz uma visão mais clara das distâncias entre os grupos a cada iteração do algoritmo.

```{r}
data.frame(k = 1:NROW(agrupamento_h$height),
           height = agrupamento_h$height) %>% 
    ggplot(aes(x = k, y = height)) + 
    geom_line(colour = "grey") + 
    geom_point() + 
    labs(x = "Junções feitas (14 no total)", y = "Dissimilaridade na junção")
```

Vemos que da 11ª junção para a 12º a distância entre os grupos já é bem maior do que qualquer outra anterior. Então, ficamos convencidos que de acordo com esse algoritmo de aglomeração hierárquica há quatro grupos distintos de filmes quanto à avaliação.

Abaixo temos outra visualização. Nesta, podemos ver quais os grupos formados pelos algoritmo para vários números de grupo.

```{r}
solucoes = tibble(k = 1:9)

atribuicoes = solucoes %>% 
    group_by(k) %>% 
    do(cbind(filmes, 
             grupo = as.character(cutree(agrupamento_h, .$k)))) 

atribuicoes %>% 
    ggplot(aes(x = "Filmes", y = avaliação, colour = grupo)) + 
    geom_jitter(width = .02, height = 0, size = 2, alpha = .6) + 
    facet_wrap(~ paste(k, " grupos"))
```

Dividir os filmes em quatro grupos também parece ser uma das escolhas mais sensatas de acordo com o gráfico acima.

<i> Observação: O método utilizado para o agrupamento neste exemplo é o "Ward". Há mais informações sobre esse método na sua [documentação](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/hclust.html) </i>

#### Variável: Bilheteria

Vamos agora utilizar a variável bilheteria para agrupar os filmes. Só que iremos fazer um agrupamento utilizando a escala linear e outro utilizando a escala logarítmica e iremos comparar as duas abordagens.

##### Escala linear

```{r}
row.names(filmes) = NULL
agrupamento_h = filmes %>% 
    column_to_rownames("filme") %>% # hclust precisa dos rótulos em nomes de linha (ruim)
    select(bilheteria) %>%
    dist(method = "euclidian") %>% 
    hclust(method = "ward.D2")

ggdendrogram(agrupamento_h, rotate = T, size = 2) + 
    geom_hline(yintercept = 200, colour = "red")

solucoes = tibble(k = 1:9)

atribuicoes = solucoes %>% 
    group_by(k) %>% 
    do(cbind(filmes, 
             grupo = as.character(cutree(agrupamento_h, .$k)))) 

atribuicoes %>% 
    ggplot(aes(x = "Filmes", y = bilheteria, colour = grupo)) + 
    geom_jitter(width = .02, height = 0, size = 2, alpha = .6) + 
    facet_wrap(~ paste(k, " grupos"))

```

##### Escala logarítmica

```{r}
row.names(filmes) = NULL
agrupamento_h = filmes %>% 
    column_to_rownames("filme") %>% # hclust precisa dos rótulos em nomes de linha (ruim)
    select(bilheteria) %>%
    dist(method = "euclidian") %>% 
    hclust(method = "ward.D2")

ggdendrogram(agrupamento_h, rotate = T, size = 2) + 
    geom_hline(yintercept = 200, colour = "red")

solucoes = tibble(k = 1:9)

atribuicoes = solucoes %>% 
    group_by(k) %>% 
    do(cbind(filmes, 
             grupo = as.character(cutree(agrupamento_h, .$k)))) 

atribuicoes %>% 
    ggplot(aes(x = "Filmes", y = bilheteria, colour = grupo)) + 
    geom_jitter(width = .02, height = 0, size = 2, alpha = .6) + 
    facet_wrap(~ paste(k, " grupos")) +
   scale_y_log10()
```





















